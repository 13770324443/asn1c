
/*** <<< INCLUDES [Everything] >>> ***/

#include <Choice1.h>
#include <Choice2.h>
#include <Set.h>
#include <constr_SEQUENCE.h>

/*** <<< TYPE-DECLS [Everything] >>> ***/

typedef struct Everything {
	Choice1_t	 ch1;
	Choice2_t	 ch2;
	Set_t	 set;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} Everything_t;

/*** <<< FUNC-DECLS [Everything] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Everything;

/*** <<< STAT-DEFS [Everything] >>> ***/

static asn_TYPE_member_t asn_MBR_Everything_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct Everything, ch1),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = +1,	/* EXPLICIT tag at current level */
		.type = (void *)&asn_DEF_Choice1,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.name = "ch1"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct Everything, ch2),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = +1,	/* EXPLICIT tag at current level */
		.type = (void *)&asn_DEF_Choice2,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.name = "ch2"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct Everything, set),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = (void *)&asn_DEF_Set,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.name = "set"
		},
};
static ber_tlv_tag_t asn_DEF_Everything_1_tags[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_Everything_1_tag2el[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* ch1 at 15 */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* ch2 at 16 */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* set at 18 */
};
static asn_SEQUENCE_specifics_t asn_SPC_Everything_1_specs = {
	sizeof(struct Everything),
	offsetof(struct Everything, _asn_ctx),
	asn_MAP_Everything_1_tag2el,
	3,	/* Count of tags in the map */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_Everything = {
	"Everything",
	"Everything",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_Everything_1_tags,
	sizeof(asn_DEF_Everything_1_tags)
		/sizeof(asn_DEF_Everything_1_tags[0]), /* 1 */
	asn_DEF_Everything_1_tags,	/* Same as above */
	sizeof(asn_DEF_Everything_1_tags)
		/sizeof(asn_DEF_Everything_1_tags[0]), /* 1 */
	asn_MBR_Everything_1,
	3,	/* Elements count */
	&asn_SPC_Everything_1_specs	/* Additional specs */
};


/*** <<< INCLUDES [Choice1] >>> ***/

#include <constr_CHOICE.h>

/*** <<< DEPS [Choice1] >>> ***/

typedef enum Choice1_PR {
	Choice1_PR_NOTHING,	/* No components present */
	Choice1_PR_something,
	/* Extensions may appear below */
	Choice1_PR_some2,
} Choice1_PR;

/*** <<< FWD-DECLS [Choice1] >>> ***/

struct Everything;

/*** <<< TYPE-DECLS [Choice1] >>> ***/

typedef struct Choice1 {
	Choice1_PR present;
	union Choice1_u {
		struct Everything	*something;
		/*
		 * This type is extensible,
		 * possible extensions are below.
		 */
		struct Everything	*some2;
	} choice;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} Choice1_t;

/*** <<< FUNC-DECLS [Choice1] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Choice1;

/*** <<< POST-INCLUDE [Choice1] >>> ***/

#include <Everything.h>

/*** <<< STAT-DEFS [Choice1] >>> ***/

static asn_TYPE_member_t asn_MBR_Choice1_1[] = {
	{ ATF_POINTER, 0, offsetof(struct Choice1, choice.something),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = (void *)&asn_DEF_Everything,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.name = "something"
		},
	{ ATF_POINTER, 0, offsetof(struct Choice1, choice.some2),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = (void *)&asn_DEF_Everything,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.name = "some2"
		},
};
static asn_TYPE_tag2member_t asn_MAP_Choice1_1_tag2el[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* something at 22 */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* some2 at 25 */
};
static asn_CHOICE_specifics_t asn_SPC_Choice1_1_specs = {
	sizeof(struct Choice1),
	offsetof(struct Choice1, _asn_ctx),
	offsetof(struct Choice1, present),
	sizeof(((struct Choice1 *)0)->present),
	asn_MAP_Choice1_1_tag2el,
	2,	/* Count of tags in the map */
	1	/* Whether extensible */
};
asn_TYPE_descriptor_t asn_DEF_Choice1 = {
	"Choice1",
	"Choice1",
	CHOICE_free,
	CHOICE_print,
	CHOICE_constraint,
	CHOICE_decode_ber,
	CHOICE_encode_der,
	CHOICE_decode_xer,
	CHOICE_encode_xer,
	CHOICE_outmost_tag,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	asn_MBR_Choice1_1,
	2,	/* Elements count */
	&asn_SPC_Choice1_1_specs	/* Additional specs */
};


/*** <<< INCLUDES [Choice2] >>> ***/

#include <constr_CHOICE.h>

/*** <<< DEPS [Choice2] >>> ***/

typedef enum Choice2_PR {
	Choice2_PR_NOTHING,	/* No components present */
	/* Extensions may appear below */
	Choice2_PR_some3,
} Choice2_PR;

/*** <<< FWD-DECLS [Choice2] >>> ***/

struct Everything;

/*** <<< TYPE-DECLS [Choice2] >>> ***/

typedef struct Choice2 {
	Choice2_PR present;
	union Choice2_u {
		/*
		 * This type is extensible,
		 * possible extensions are below.
		 */
		struct Everything	*some3;
	} choice;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} Choice2_t;

/*** <<< FUNC-DECLS [Choice2] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Choice2;

/*** <<< POST-INCLUDE [Choice2] >>> ***/

#include <Everything.h>

/*** <<< STAT-DEFS [Choice2] >>> ***/

static asn_TYPE_member_t asn_MBR_Choice2_1[] = {
	{ ATF_POINTER, 0, offsetof(struct Choice2, choice.some3),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = (void *)&asn_DEF_Everything,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.name = "some3"
		},
};
static asn_TYPE_tag2member_t asn_MAP_Choice2_1_tag2el[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 } /* some3 at 30 */
};
static asn_CHOICE_specifics_t asn_SPC_Choice2_1_specs = {
	sizeof(struct Choice2),
	offsetof(struct Choice2, _asn_ctx),
	offsetof(struct Choice2, present),
	sizeof(((struct Choice2 *)0)->present),
	asn_MAP_Choice2_1_tag2el,
	1,	/* Count of tags in the map */
	1	/* Whether extensible */
};
asn_TYPE_descriptor_t asn_DEF_Choice2 = {
	"Choice2",
	"Choice2",
	CHOICE_free,
	CHOICE_print,
	CHOICE_constraint,
	CHOICE_decode_ber,
	CHOICE_encode_der,
	CHOICE_decode_xer,
	CHOICE_encode_xer,
	CHOICE_outmost_tag,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	asn_MBR_Choice2_1,
	1,	/* Elements count */
	&asn_SPC_Choice2_1_specs	/* Additional specs */
};


/*** <<< INCLUDES [Set] >>> ***/

#include <asn_SET_OF.h>
#include <INTEGER.h>
#include <Sequence.h>
#include <constr_SEQUENCE.h>
#include <constr_SET_OF.h>

/*** <<< FWD-DECLS [Set] >>> ***/

struct Set;

/*** <<< TYPE-DECLS [Set] >>> ***/

typedef struct Set {
	A_SET_OF(struct Member {
		INTEGER_t	 Int;
		struct Set	*set;
		Sequence_t	 seq;
		struct Set	*set2	/* OPTIONAL */;
		/*
		 * This type is extensible,
		 * possible extensions are below.
		 */
		struct Set	*set3;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} ) list;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} Set_t;

/*** <<< FUNC-DECLS [Set] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Set;

/*** <<< POST-INCLUDE [Set] >>> ***/

#include <Set.h>

/*** <<< STAT-DEFS [Set] >>> ***/

static asn_TYPE_member_t asn_MBR_Member_2[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct Member, Int),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = (void *)&asn_DEF_INTEGER,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.name = "int"
		},
	{ ATF_POINTER, 0, offsetof(struct Member, set),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = (void *)&asn_DEF_Set,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.name = "set"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct Member, seq),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = (void *)&asn_DEF_Sequence,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.name = "seq"
		},
	{ ATF_POINTER, 2, offsetof(struct Member, set2),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = (void *)&asn_DEF_Set,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.name = "set2"
		},
	{ ATF_POINTER, 0, offsetof(struct Member, set3),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = (void *)&asn_DEF_Set,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.name = "set3"
		},
};
static ber_tlv_tag_t asn_DEF_Member_2_tags[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_Member_2_tag2el[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* int at 33 */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* set at 34 */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* seq at 35 */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* set2 at 36 */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 } /* set3 at 39 */
};
static asn_SEQUENCE_specifics_t asn_SPC_Member_2_specs = {
	sizeof(struct Member),
	offsetof(struct Member, _asn_ctx),
	asn_MAP_Member_2_tag2el,
	5,	/* Count of tags in the map */
	3,	/* Start extensions */
	6	/* Stop extensions */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_Member_2 = {
	"",
	"",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_Member_2_tags,
	sizeof(asn_DEF_Member_2_tags)
		/sizeof(asn_DEF_Member_2_tags[0]), /* 1 */
	asn_DEF_Member_2_tags,	/* Same as above */
	sizeof(asn_DEF_Member_2_tags)
		/sizeof(asn_DEF_Member_2_tags[0]), /* 1 */
	asn_MBR_Member_2,
	5,	/* Elements count */
	&asn_SPC_Member_2_specs	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_Set_1[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
		.tag_mode = 0,
		.type = (void *)&asn_DEF_Member_2,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.name = ""
		},
};
static ber_tlv_tag_t asn_DEF_Set_1_tags[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (17 << 2))
};
static asn_SET_OF_specifics_t asn_SPC_Set_1_specs = {
	sizeof(struct Set),
	offsetof(struct Set, _asn_ctx),
	0,	/* XER encoding is XMLDelimitedItemList */
};
asn_TYPE_descriptor_t asn_DEF_Set = {
	"Set",
	"Set",
	SET_OF_free,
	SET_OF_print,
	SET_OF_constraint,
	SET_OF_decode_ber,
	SET_OF_encode_der,
	SET_OF_decode_xer,
	SET_OF_encode_xer,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_Set_1_tags,
	sizeof(asn_DEF_Set_1_tags)
		/sizeof(asn_DEF_Set_1_tags[0]), /* 1 */
	asn_DEF_Set_1_tags,	/* Same as above */
	sizeof(asn_DEF_Set_1_tags)
		/sizeof(asn_DEF_Set_1_tags[0]), /* 1 */
	asn_MBR_Set_1,
	1,	/* Single element */
	&asn_SPC_Set_1_specs	/* Additional specs */
};


/*** <<< INCLUDES [Sequence] >>> ***/

#include <INTEGER.h>
#include <constr_SEQUENCE.h>

/*** <<< FWD-DECLS [Sequence] >>> ***/

struct Sequence;
struct Set;

/*** <<< TYPE-DECLS [Sequence] >>> ***/

typedef struct Sequence {
	INTEGER_t	 a;
	struct Sequence	*seq	/* OPTIONAL */;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	INTEGER_t	*b;
	struct Set	*set	/* OPTIONAL */;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} Sequence_t;

/*** <<< FUNC-DECLS [Sequence] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Sequence;

/*** <<< POST-INCLUDE [Sequence] >>> ***/

#include <Sequence.h>
#include <Set.h>

/*** <<< STAT-DEFS [Sequence] >>> ***/

static asn_TYPE_member_t asn_MBR_Sequence_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct Sequence, a),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = (void *)&asn_DEF_INTEGER,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.name = "a"
		},
	{ ATF_POINTER, 3, offsetof(struct Sequence, seq),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = (void *)&asn_DEF_Sequence,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.name = "seq"
		},
	{ ATF_POINTER, 0, offsetof(struct Sequence, b),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = (void *)&asn_DEF_INTEGER,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.name = "b"
		},
	{ ATF_POINTER, 1, offsetof(struct Sequence, set),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = (void *)&asn_DEF_Set,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.name = "set"
		},
};
static ber_tlv_tag_t asn_DEF_Sequence_1_tags[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_Sequence_1_tag2el[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* a at 42 */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* seq at 43 */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* b at 45 */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 } /* set at 46 */
};
static asn_SEQUENCE_specifics_t asn_SPC_Sequence_1_specs = {
	sizeof(struct Sequence),
	offsetof(struct Sequence, _asn_ctx),
	asn_MAP_Sequence_1_tag2el,
	4,	/* Count of tags in the map */
	1,	/* Start extensions */
	5	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_Sequence = {
	"Sequence",
	"Sequence",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_Sequence_1_tags,
	sizeof(asn_DEF_Sequence_1_tags)
		/sizeof(asn_DEF_Sequence_1_tags[0]), /* 1 */
	asn_DEF_Sequence_1_tags,	/* Same as above */
	sizeof(asn_DEF_Sequence_1_tags)
		/sizeof(asn_DEF_Sequence_1_tags[0]), /* 1 */
	asn_MBR_Sequence_1,
	4,	/* Elements count */
	&asn_SPC_Sequence_1_specs	/* Additional specs */
};

